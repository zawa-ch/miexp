/// @0.13.3
### {
	name: "MiExp"
	author: "zawa-ch."
	description: "あなたのMisskeyでの活動から経験値を集計します"
	version: "1.1.2"
	permissions: [
		//	write:notifications
		//	ログインやレベルアップを通知するために必要になります。
		//	(設定で無効化することもできます)
		'write:notifications'
	]
	config: {
		enableNotification: {
			type: 'bool'
			label: '通知の有効化'
			description: 'このプラグインが通知を送信することを許可します。'
			default: true
		}
		commandlineHelp: {
			type: 'bool'
			label: 'コマンドラインのヘルプ'
			description: '投稿フォームのプラグインコマンドにコマンドラインのヘルプを表示するボタンを追加します。'
			default: true
		}
		debugMode: {
			type: 'bool'
			label: 'デバッグモード'
			description: 'デバッグを有効化します。有効化するとすべてのデバッグメッセージ、通知、エラー出力などがデバッグコンソールに出力されます。'
			default: false
		}
	}
}
//	1.2.0 update

let MIEXP_CONST = {
	savedata_key: 'miexp/savedata'
	activitycache_key: 'miexp/activity_cache'
	notification_head: 'MiExp'
	notification_icon: null
	//	If you want to translate, edit here
	cmd_formtitle: @(){`MiExp: コマンドライン実行`}
	help_formtitle: @(){`MiExp: コマンドラインヘルプ`}
	cmdnotfound_dialog: @(){`指定されたコマンドは存在しません。help と入力してコマンドライン実行をすることでコマンドラインヘルプを確認できます。`}
	formnotempty_dialog: @(){`フォームが空ではありません。この操作を行うには、フォームを空にする必要があります。`}
}

@MiExpSaveUtil(save) {
	@is_type(value, type) { Core:type(value) == type }
	@try_parse_json(text) {
		var result = null
		var done = false
		let a1 = Async:timeout(0, @() {
			result = Json:parse(text)
			done = true
		})
		let a2 = Async:timeout(100, @() { done = true })
		loop { if done { break } }
		a1()
		a2()
		result
	}
	//	セーブデータからバージョンを検出する
	//	save: any	セーブデータ
	//	<- num|null	検出したバージョン、検出できない場合はnull
	@detect_version(save) {
		if Core:type(save) != 'obj' { return null }
		if Core:type(save.schema) != 'obj' { return 0 }
		if Core:type(save.schema.version) != 'num' { return null }
		if save.schema.version < 1 || save.schema.version > 1 { return null }
		save.schema.version
	}
	//	特定バージョンのセーブデータの妥当性を識別する
	//	save: any	セーブデータ
	//	version: num	識別対象のバージョン
	//	<- bool	有効なセーブデータについてtrue、それ以外でfalse
	@is_valid_on(save, version) {
		//	セーブデータの妥当性を検出するバージョン別関数
		let validation_detector = [
			//	version 0 (1.0.0 - 1.0.3)
			@(save) { is_type(save.loginday, 'num') && is_type(save.loginmap, 'arr') && is_type(save.subscore, 'num') && is_type(save.score, 'num') && is_type(save.level, 'num') && is_type(save.lastupdate, 'num') }
			//	version 1 (1.1.0 -)
			@(save) {
				if Core:not(is_type(save.schema, 'obj') && is_type(save.exp, 'obj') && is_type(save.state, 'obj') && is_type(save.loginmap, 'arr')) { return false }
				if Core:not(is_type(save.schema.context, 'str') && is_type(save.schema.version, 'num')) { return false }
				if Core:not(is_type(save.exp.level, 'num') && is_type(save.exp.gauge, 'num') && is_type(save.exp.points, 'num')) { return false }
				if Core:not(is_type(save.state.login, 'num')) { return false }
				save.schema.context == SAVEDATA_CONTEXT && save.schema.version == 1
			}
		]
		if !is_type(version, 'num') { return false }
		validation_detector[version](data)
	}
	//	最新バージョン
	let LATEST_VERSION = 1
	//	セーブデータのコンテキストデータ文字列
	let SAVEDATA_CONTEXT = 'miexp'
	//	新規データの作成
	@new_data() {
		{
			schema: { context: SAVEDATA_CONTEXT, version: 1 }
			lastlogin: null
			exp: { level: 0, gauge: 0, points: 0 }
			state: { login: 0 }
			loginmap: eval {
				var a = []
				for 14 { a.push(null) }
				a
			}
		}
	}
	let LOCALTIME_DIFF = Date:parse( `{Date:year()}/{Date:month()}/{Date:day()} 0:00 UTC`) - Date:parse(`{Date:year()}/{Date:month()}/{Date:day()} 0:00` )
	//	セーブデータのアップグレードを行うバージョン別関数
	let updator = [
		//	version 0 (-> 1)
		@(save) { { schema: { context: SAVEDATA_CONTEXT, version: 1 }, lastlogin: ((save.lastupdate * 24 + 5) * 3600000 - LOCALTIME_DIFF), exp: { level: save.level, gauge: save.score, points: save.subscore }, state: { login: save.loginday }, loginmap: save.loginmap } }
		//	version 1 (latest)
		@(save) { save }
	]
	var data = if is_type(save, 'obj') { Obj:copy(save) } elif is_type(save, 'str') { try_parse_json(save) } else { null }
	{
		//	生のセーブデータを取得する
		//	<- any	セーブデータの内容(たいていの場合saveに代入した内容)
		data: @() { data }
		//	バージョンを取得する
		//	<- num|null	検出したバージョン、検出できない場合はnull
		version: @() { detect_version(data) }
		//	セーブデータの妥当性を取得する
		//	<- bool	有効なセーブデータについてtrue、それ以外でfalse
		is_valid: @() { is_valid_on(data, detect_version(data)) }
		//	アップグレード可能かを取得する
		//	<- bool	最新ではないバージョンについてtrue、それ以外でfalse
		//	note:
		//	is_latest()の単純な論理否定ではないことに注意
		//	version()がnullを返す状況ではどちらもfalseを返す
		is_upgradable: @() {
			let v = detect_version(data)
			is_type(v, 'num') && LATEST_VERSION != v
		}
		//	最新のバージョンかを取得する
		//	<- bool	最新のバージョンについてtrue、それ以外でfalse
		//	note:
		//	is_upgradable()の単純な論理否定ではないことに注意
		//	version()がnullを返す状況ではどちらもfalseを返す
		is_latest: @() {
			let v = detect_version(data)
			LATEST_VERSION == v
		}
		//	最終ログイン日時を取得する
		//	<- num|null	最終ログイン日時を表すnum、存在しないか無効な場合null
		//	note:
		//	有効な最新バージョンのデータでのみ有効であり、そうでないデータに対しては常にnullを返す
		get_lastlogin: @() { if is_valid_on(data, LATEST_VERSION) { data.lastlogin } else { null } }
		//	最終ログイン日時を設定する
		//	value: num|null	設定する値
		//	<- 成功した場合空のobj、失敗した場合はその理由を記述した.errorを含むobj
		set_lastlogin: @(value) {
			if !is_valid_on(data, LATEST_VERSION) { return { error: 'SAVEDATA_NOT_MATCH' } }
			if is_type(value, 'num') { data.lastlogin = value + 0 }
			elif is_type(value, 'null') { data.lastlogin = null }
			else { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			{}
		}
		//	経験値の状態を取得する
		//	<- obj|null	経験値の状態を表すobj、存在しないか無効な場合null
		//	note:
		//	有効な最新バージョンのデータでのみ有効であり、そうでないデータに対しては常にnullを返す
		get_exp: @() { if is_valid_on(data, LATEST_VERSION) { Obj:copy(data.exp) } else { null } }
		//	経験値の状態を設定する
		//	value: obj	設定する値
		//	<- 成功した場合空のobj、失敗した場合はその理由を記述した.errorを含むobj
		set_exp: @(value) {
			if !is_valid_on(data, LATEST_VERSION) { return { error: 'SAVEDATA_NOT_MATCH' } }
			if !is_type(value, 'obj') { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			if is_type(value.level, 'num') && is_type(value.gauge, 'num') && is_type(value.points, 'num') { data.exp = Obj:copy(value) }
			else { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			{}
		}
		//	ログイン日数を取得する
		//	<- num|null	ログイン日数を表すnum、存在しないか無効な場合null
		//	note:
		//	有効な最新バージョンのデータでのみ有効であり、そうでないデータに対しては常にnullを返す
		get_logincount: @() { if is_valid_on(data, LATEST_VERSION) { data.state.login } else { null } }
		//	ログイン日数を設定する
		//	value: num	設定する値
		//	<- 成功した場合空のobj、失敗した場合はその理由を記述した.errorを含むobj
		set_logincount: @(value) {
			if !is_valid_on(data, LATEST_VERSION) { return { error: 'SAVEDATA_NOT_MATCH' } }
			if is_type(value, 'num') { data.state.login = value + 0 }
			else { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			{}
		}
		//	ログイン間隔マップを取得する
		//	<- arr|null	ログイン間隔マップを表すarr、存在しないか無効な場合null
		//	note:
		//	有効な最新バージョンのデータでのみ有効であり、そうでないデータに対しては常にnullを返す
		get_loginmap: @() { if is_valid_on(data, LATEST_VERSION) { data.loginmap.copy() } else { null } }
		//	ログイン間隔マップを設定する
		//	value: arr	設定する値
		//	<- 成功した場合空のobj、失敗した場合はその理由を記述した.errorを含むobj
		set_loginmap: @(value) {
			if !is_valid_on(data, LATEST_VERSION) { return { error: 'SAVEDATA_NOT_MATCH' } }
			if !is_type(value, 'arr') { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			if value.map(@(i) { is_type(i, 'num') || is_type(i, 'null') }).reduce(@(a,i,n) {a && i}, true) { data.loginmap = value.copy() }
			else { return { error: 'VALUE_TYPE_NOT_MATCH' } }
			{}
		}
		//	セーブデータのアップグレードを行う
		upgrade: @() {
			var v = detect_version(data)
			if !is_type(v, 'num') { return { error: 'VERSION_CANT_DETECT' } }
			if !is_valid_on(data, v) { return { error: 'INVALID_SAVEDATA' } }
			if LATEST_VERSION == v { return { result: 'NO_UPDATE_NEEDED' } }
			var s = Obj:copy(data)
			loop {
				s = updator[v](s)
				let nv = detect_version(s)
				if nv != (v + 1) { return { error: 'VERSION_ASSERTION_FAILED' } }
				if !is_valid_on(s, nv) { return { error: 'SCHEMA_ASSERTION_FAILED' } }
				if LATEST_VERSION == nv { break }
				v = nv
			}
			data = s
			{ result: 'UPDATED' }
		}
		//	セーブデータを初期化する
		initialize: @() { data = new_data() }
	}
}

@MiExp(context) {
	@check_type(obj, type) { Core:type(obj) == type }
	@value_or(value, alt) { if !check_type(value 'null') { value } else { alt } }
	//	ゲージ1本分の経験値量
	let EXP_GAUGE_CAPACITY = 256
	//	ローカライゼーションデータ
	//	If you want to translate, edit here
	let LOCALIZATION = {
		welcome_message: @(){`**MiExp**へようこそ！{Str:lf}{Str:lf}このプラグインは通知を使用します。{Str:lf}設定を変更することで無効化することも可能です。{Str:lf}`}
		earnedexp_message: @(exp){`獲得した経験値: {exp}`}
		earnedexp_base: @(exp){`<small>- 基本ポイント: {exp}</small>`}
		earnedexp_unidirectional: @(exp){`<small>- 単方向的活動ポイント: {exp}</small>`}
		earnedexp_bidirectional: @(exp){`<small>- 双方向的活動ポイント: {exp}</small>`}
		levelup_message: @(){`レベルアップしました！`}
		level_title: @(){`**MiExp 現在のレベル**`}
		logindays: @(days){`ログイン日数: **{days}**日`}
		currentlevel: @(lv){`現在のレベル: **{lv}**`}
		level_progress: @(x, sub, scale, next){`現在の経験値: **{Math:floor((x+sub/scale)/next*10000)/100}%** (**[{x}]**<small>**+{sub}** /[{next}]</small>)`}
		datanotexist_head: @(){`データがありません`}
		datanotexist_body: @(){`MiExpのデータが存在しないため、現在のレベルを確認できません。`}
		invalidtype_dialog_head: @(){`形式が異なります`}
		invalidtype_dialog_body: @(){`入力されたデータは有効なMiExpデータではありません。`}
		upgradefailure_dialog_head: @(){`アップグレードに失敗しました`}
		upgradefailure_dialog_body: @(){`入力されたデータを最新のバージョンに変換するときに問題が発生しました。`}
		overwrite_dialog_head: @(){`この操作はデータを上書きします`}
		overwrite_dialog_body: @(){`この操作によってもとあったデータは失われます。取り消すことはできません。`}
		erase_dialog_head: @(){`データを削除します`}
		erase_dialog_body: @(){`この操作によってデータは失われます。取り消すことはできません。後悔しませんね?`}
		cmdhelp: @(){[
			`MiExp ヘルプ`
			``
			`**利用可能なコマンド**(すべてのコマンドは大文字小文字を区別します)`
			`help    このヘルプを表示する`
			`share   共有テキストを表示する`
			`export  MiExpデータのエクスポートを行う`
			`import <jsonobject>`
			`        MiExpデータのインポートを行う`
			`reset   MiExpデータを消去する`
			`なにも入力せずにコマンドラインを実行するとshareが実行されます。`
			``
			`**MiExp 経験値**`
			`MiExp経験値はその日の最初のログイン時に加算されます。`
			`経験値に影響する要素は以下のとおりです。`
			`・直近のログイン日数`
			`・フォローの数`
			`・直近のフォロー解除`
			`・前日のノート`
			`・前日のリアクション`
			`MiExp経験値にはゲージが存在し、{EXP_GAUGE_CAPACITY}経験値で1本分のゲージになります。`
			`ゲージを一定数貯めることでレベルを上げることができます。`
			`レベルアップに必要なゲージ数は現在のレベルによって変化します。`
			`tips: 一日に大量のアクティビティを行うよりも、毎日ログインを行って継続的に活動したほうが効率が良くなるよう、経験値アルゴリズムは調整されています。`
			``
			`**MiExp利用上の注意**`
			`MiExpはMisskeyプラグインの特性上、知識があればデータの変更やコードの改変を行うことが簡単にできます。`
			`MiExpは人との競争を目的として開発されたものではありません。節度をもって楽しく活用してください。`
		].join(Str:lf)}
	}
	if !check_type(context, 'obj') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context type is not obj' } } }
	if !check_type(context.load, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.load type is not fn' } } }
	if !check_type(context.save, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.save type is not fn' } } }
	if !check_type(context.get_activity, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.get_activity type is not fn' } } }
	@dbg(msg) { if check_type(context.debug, 'fn') { context.debug(msg) } }
	//	ログインマップデータの更新
	@update_loginmap(map, duration) {
		var r = map.copy()
		r.reverse()
		r.push(duration)
		r.reverse()
		r.slice(0, 14)
	}
	//	AiScript標準日付 -> Miexp日付データ変換
	//	date: num	AiScriptで使用される日付データ
	@convert_date(date) {
		let LOCALTIME_DIFF = Date:parse( `{Date:year(date)}/{Date:month(date)}/{Date:day(date)} 0:00 UTC`) - Date:parse(`{Date:year(date)}/{Date:month(date)}/{Date:day(date)} 0:00` )
		Math:floor(((date + LOCALTIME_DIFF) / 3600000 - 5) / 24)
	}
	//	経験値計算
	@calc_exp(activitydata) {
		let result = eval {
			let b = Math:floor( Math:sqrt( activitydata.login_freq / 14 ) * 128)
			let ud = Math:floor( Math:sqrt(Math:sqrt( (activitydata.notes.normal + Math:sqrt(activitydata.notes.renote)) / 128 )) * 128 )
			let bd = eval {
				let bd_a = eval {
					let score = activitydata.notes.reply * 4 + activitydata.reaction
					let parts = [
						Math:sqrt( score / 256 ) * (256 - Math:min(score, 256)) / 256 * (256 - Math:min(activitydata.follow.following, 256)) / 256
						Math:sqrt(Math:sqrt(Math:sqrt( score / 256 ))) * Math:min(score, 256) / 256 * (256 - Math:min(activitydata.follow.following, 256)) / 256
						Math:sqrt( score / Math:sqrt(Math:max(1, activitydata.follow.following) / 256) / 256 ) * (256 - Math:min(score / Math:sqrt(Math:max(1, activitydata.follow.following) / 256), 256)) / 512 * Math:min(activitydata.follow.following, 256) / 256
						Math:sqrt(Math:sqrt(Math:sqrt( score / Math:sqrt(Math:max(1, activitydata.follow.following) / 256) / 256 ))) * Math:min(score / Math:sqrt(Math:max(1, activitydata.follow.following) / 256), 256) / 256 * Math:min(activitydata.follow.following, 256) / 256
					]
					{ score: score, parts: parts, result: parts[0] + parts[1] + parts[2] + parts[3] }
				}
				var bd_f = eval {
					let parts = [
						Math:sqrt(Math:sqrt( activitydata.follow.following / 256 )) * (256 - Math:min(activitydata.follow.following, 256)) / 256
						Math:sqrt(Math:sqrt(Math:sqrt( activitydata.follow.following / 256 ))) * Math:min(activitydata.follow.following, 256) / 256
					]
					{ parts: parts, result: Math:max(0, parts[0] + parts[1] - activitydata.follow.remove / 64) }
				}
				{ follow: bd_f, activity: bd_a, result: Math:floor( bd_f.result * bd_a.result * 256 ) }
			}
			{ params: activitydata, base: b, unidirectinal: ud, bidirectional: bd, result: b + ud + bd.result }
		}
		dbg(Json:stringify(result))
		result
	}
	//	次レベルまでに必要なゲージ数の取得
	@calc_nextlevel(level) { 1 + Math:floor( Math:sqrt(level / 64) * 8 ) }
	//	レベルアップ処理
	@levelup(current, earned) {
		var r = {
			level: current.level + 0
			gauge: Math:floor(value_or(current.gauge, 0) + (value_or(current.points, 0) + earned) / EXP_GAUGE_CAPACITY)
			points: Math:floor((value_or(current.points, 0) + earned) % EXP_GAUGE_CAPACITY)
		}
		loop {
			let g = calc_nextlevel(r.level)
			if r.gauge < g { break }
			r.gauge = r.gauge - g
			r.level = r.level + 1
		}
		r
	}
	//	セーブデータが新規データであるかを取得
	@is_newdata(save) { !save.is_valid() }
	//	セーブデータが有効であるかを取得
	@is_validdata(save) { save.is_valid() && save.is_latest() }
	//	セーブデータとその日との日数の差を取得
	@login_duration(save, date) { convert_date(date) - convert_date(value_or(save.get_lastlogin(), 0)) }
	//	その日のログイン処理を行えるかを取得
	@is_login_available(save, date) {
		if is_newdata(data) { return true }
		if !check_type(save.get_lastlogin(), 'num') { return true }
		login_duration(save, date) > 0
	}
	var data = MiExpSaveUtil(context.load())
	dbg('loaded savedata')
	dbg(Json:stringify({ savedata: data.data() }))

	{
		//	ヘルプを表示するための要素を取得
		help: @() {
			dbg('@Miexp:help')
			let message = LOCALIZATION.cmdhelp()
			{ message: message }
		}
		//	共有用テキスト要素を取得
		share: @() {
			dbg('@Miexp:share')
			if !is_validdata(data) {
				return { error: { code: 'SAVEDATA_NOT_EXIST', message: LOCALIZATION.datanotexist_body(), title: LOCALIZATION.datanotexist_head() } }
			}
			let message = [
				LOCALIZATION.level_title()
				LOCALIZATION.logindays(data.get_logincount())
				LOCALIZATION.currentlevel(data.get_exp().level)
				LOCALIZATION.level_progress(data.get_exp().gauge, data.get_exp().points, EXP_GAUGE_CAPACITY, calc_nextlevel(data.get_exp().level))
			].join(Str:lf)
			{ message: message }
		}
		//	その日のログイン処理を行えるかを取得
		is_login_available: @() {
			dbg('@Miexp:is_login_available')
			{ result: is_login_available(data, Date:now()) }
		}
		//	ログイン処理を実行
		login: @() {
			dbg('@Miexp:login')
			let current_time = Date:now()
			if !is_login_available(data, current_time) {
				dbg('already logged in')
				return { result: 'ALREADY_LOGGED_IN', message: null }
			}
			var message = []
			if is_newdata(data) {
				dbg('new data')
				message.push(LOCALIZATION.welcome_message())
				data.initialize()
			}
			dbg(Json:stringify({data: data.data()}))
			if !is_validdata(data) {
				return { error: { code: 'INVALID_SAVEDATA', message: 'Invalid savedata loaded.' } }
			}
			let loginmap = if Core:type(data.get_lastlogin()) == 'num' { update_loginmap(data.get_loginmap(), login_duration(data, current_time)) } else { data.get_loginmap() }
			dbg(Json:stringify({ loginmap: loginmap }))
			let login_freq = eval {
				var r = 0
				var d = 0
				for let i, Math:min(loginmap.len, 14) {
					r += 1
					d += value_or(loginmap[i], 1)
					if d >= 14 { break }
				}
				r
			}
			let activity = context.get_activity()
			dbg(Json:stringify({ activity: activity }))
			if !check_type(activity, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.normal, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.normal', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.renote, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.renote', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.reply, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.reply', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow.following, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow.following', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow.remove, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow.remove', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.reaction, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.reaction', message: 'Callback "get_activity" returns invalid object.' } } }
			let earned_exp = calc_exp({login_freq: login_freq, notes: activity.notes, follow: activity.follow, reaction: activity.reaction})
			dbg(Json:stringify({earned_exp: earned_exp}))
			message.push(LOCALIZATION.earnedexp_message(earned_exp.result))
			message.push(LOCALIZATION.earnedexp_base(earned_exp.base))
			message.push(LOCALIZATION.earnedexp_unidirectional(earned_exp.unidirectinal))
			message.push(LOCALIZATION.earnedexp_bidirectional(earned_exp.bidirectional.result))
			let old_level = value_or(data.get_exp().level, 0)
			let new_exp = levelup(data.get_exp(), earned_exp.result)
			dbg(Json:stringify({ old_level: old_level, new_exp: new_exp }))
			if (!is_newdata(data)) && (old_level < new_exp.level) {
				dbg(`level up`)
				message.push(LOCALIZATION.levelup_message())
			}
			data.set_lastlogin(current_time)
			data.set_exp(new_exp)
			data.set_logincount(value_or(data.get_logincount(), 0) + 1)
			data.set_loginmap(loginmap)
			dbg(Json:stringify({ updated_savedata: data.data() }))
			message.push('')
			message.push(LOCALIZATION.level_title())
			message.push(LOCALIZATION.logindays(data.get_logincount()))
			message.push(LOCALIZATION.currentlevel(data.get_exp().level))
			message.push(LOCALIZATION.level_progress(data.get_exp().gauge, data.get_exp().points, EXP_GAUGE_CAPACITY, calc_nextlevel(data.get_exp().level)))
			context.save(data.data())
			{ result: 'LOGIN_SUCCESS', message: message.join(Str:lf) }
		}
		//	データのエクスポート
		export_data: @() {
			dbg('@Miexp:export_data')
			if !is_validdata(data) {
				return { error: { code: 'SAVEDATA_NOT_EXIST', message: LOCALIZATION.datanotexist_body(), title: LOCALIZATION.datanotexist_head() } }
			}
			{ result: data.data(), to_json: @() { Json:stringify(data.data()) } }
		}
		//	データのインポート
		import_data: @(new_data) {
			dbg('@Miexp:import_data')
			dbg(Json:stringify({new_data: new_data}))
			let s = MiExpSaveUtil(new_data)
			if !s.is_valid() {
				return { error: { code: 'INVALID_SAVEDATA', message: LOCALIZATION.invalidtype_dialog_body(), title: LOCALIZATION.invalidtype_dialog_head() } }
			}
			if s.is_upgradable() {
				let r = s.upgrade()
				if !check_type(r.error, 'null') { return { error: { code: 'SAVEDATA_UPGRADE_FAILED', inner: r.error, message: LOCALIZATION.upgradefailure_dialog_body(), title: LOCALIZATION.upgradefailure_dialog_head() } } }
			}
			{
				message: LOCALIZATION.overwrite_dialog_body()
				title: LOCALIZATION.overwrite_dialog_head()
				confirm: @() {
					data = s
					context.save(s.data())
					{ result: 'SUCCESS' }
				}
			}
		}
		//	データの消去
		reset: @() {
			dbg('@Miexp:reset')
			{
				message: LOCALIZATION.erase_dialog_body()
				title: LOCALIZATION.erase_dialog_head()
				confirm: @() {
					data = MiExpSaveUtil(null)
					context.save(null)
					{ result: 'SUCCESS' }
				}
			}
		}
	}
}

//	nullの場合に代替オブジェクトを適用
@value_or(value, alt) { if Core:type(value) != 'null' { value } else { alt } }

//	文字列が指定した文字列から開始するかを取得
@starts_with(str, search) { str.index_of(search) == 0 }

//	文字列から指定した文字列以前の文字列を取得
@slice_before_with(str, search) {
	let i = str.index_of(search)
	if i >= 0 { str.slice(0, i) } else { null }
}

//	文字列から指定した文字列以降の文字列を取得
@slice_after_with(str, search) {
	let i = str.index_of(search)
	if i >= 0 { str.slice((i+search.len), str.len) } else { null }
}

@sum(array) {
	var result = 0
	for let i, array.len { result += array[i] }
	result
}

@merge(a1, a2) {
	let l = Math:max(a1.len, a2.len)
	let a = []
	for let i, l { a.push(i) }
	a.map(@(i) { a1[i] + a2[i] })
}

//	Misskey API 通知送信
@miexp_notify(body) { if Plugin:config.enableNotification { Mk:api('notifications/create' { body: body, header: MIEXP_CONST.notification_head, icon: MIEXP_CONST.notification_icon }) } }

//	プラグインデータ保存
@miexp_save(data) { Mk:save(MIEXP_CONST.savedata_key, data) }

//	プラグインデータ取得
@miexp_load() { Mk:load(MIEXP_CONST.savedata_key) }

//	経験値集計用データをMiExp本体に通知
@miexp_get_activity() {
	let activity = Mk:load(MIEXP_CONST.activitycache_key).activity
	Mk:save(MIEXP_CONST.activitycache_key, null)
	activity
}

//	チャートから経験値計算用のデータを取得
@miexp_collect_chart(inst) {
	if Plugin:config.debugMode { <: '@miexp_collect_chart' }
	var c = Mk:load(MIEXP_CONST.activitycache_key)
	if Core:type(c) != 'obj' { c = { activity: {}, wait_time: 5000 } }
	let chart_notes = Mk:api('charts/user/notes' { span: 'hour', limit: 24, userId: USER_ID })
	let chart_following = Mk:api('charts/user/following' { span: 'day', limit: 14, userId: USER_ID })
	let chart_reactions = Mk:api('charts/user/reactions' { span: 'hour', limit: 24, userId: USER_ID })
	if Plugin:config.debugMode { <: { chart_notes: chart_notes, chart_following: chart_following, chart_reactions: chart_reactions } }
	if Core:type(c.activity.notes) != 'obj' {
		c.activity.notes = eval {
			if Core:type(chart_notes.diffs) != 'obj' { return null }
			if Core:type(chart_notes.diffs.normal) != 'arr' { return null }
			if Core:type(chart_notes.diffs.renote) != 'arr' { return null }
			if Core:type(chart_notes.diffs.reply) != 'arr' { return null }
			{
				normal: Math:max(0, sum(chart_notes.diffs.normal))
				renote: Math:max(0, sum(chart_notes.diffs.renote))
				reply: Math:max(0, sum(chart_notes.diffs.reply))
			}
		}
	}
	if Core:type(c.activity.follow) != 'obj' {
		c.activity.follow = eval {
			if Core:type(chart_following.local) != 'obj' { return null }
			if Core:type(chart_following.local.followings) != 'obj' { return null }
			if Core:type(chart_following.local.followings.total[0]) != 'num' { return null }
			if Core:type(chart_following.local.followings.dec) != 'arr' { return null }
			{
				following: chart_following.local.followings.total[0]
				remove: sum(chart_following.local.followings.dec)
			}
		}
	}
	if Core:type(c.activity.reaction) != 'num' {
		c.activity.reaction = eval {
			if Core:type(chart_reactions.local) != 'obj' { return null }
			if Core:type(chart_reactions.local.count) != 'arr' { return null }
			if Core:type(chart_reactions.remote) != 'obj' { return null }
			if Core:type(chart_reactions.remote.count) != 'arr' { return null }
			sum(merge(chart_reactions.local.count, chart_reactions.remote.count))
		}
	}
	if Plugin:config.debugMode { <: c }
	let wait_time = c.wait_time
	c.wait_time = Math:min(c.wait_time * 6, 300000)
	Mk:save(MIEXP_CONST.activitycache_key, c)
	if Core:type(c.activity.notes) == 'obj' && Core:type(c.activity.follow) == 'obj' && Core:type(c.activity.reaction) == 'num' {
		if Plugin:config.debugMode { <: 'Data corrected, run login task' }
		let result = inst.login()
		if Plugin:config.debugMode { <: result }
		elif Core:type(result.error) != 'null' {
			<: result
			Mk:dialog(MIEXP_CONST.notification_head, `MiExp login returned error {result.error.code}`, 'error')
		}
		elif Core:type(result.message) == 'str' { miexp_notify(result.message) }
		else {}
	} else {
		if Plugin:config.debugMode { <: `Data fetch failed, retry in {wait_time}ms` }
		Async:timeout(wait_time, @() { miexp_collect_chart(inst) })
	}
}

let miexp_context = {
	save: miexp_save
	load: miexp_load
	get_activity: miexp_get_activity
	debug: if Plugin:config.debugMode { @(obj) { <: obj } } else { null }
}

@on_load() {
	if Plugin:config.debugMode { <: '@on_load' }
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	if inst.is_login_available().result {
		Mk:save(MIEXP_CONST.activitycache_key, null)
		miexp_collect_chart(inst)
	}
}

@on_cmd(note, update) {
	if Plugin:config.debugMode { <: '@on_cmd' }
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	let command = if note.text.len > 0 { value_or(slice_before_with(note.text ' ') note.text) } else { 'share' }
	if Plugin:config.debugMode { <: command }
	match (command) {
		'help' => eval {
			update('text', inst.help().message)
		}
		'share' => eval {
			let result = inst.share()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', result.message)
		}
		'export' => eval {
			let result = inst.export_data()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', result.to_json())
		}
		'import' => eval {
			let import_data = Json:parse(value_or(slice_after_with(note.text ' ') 'null'))
			var result = inst.import_data(import_data)
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			if !Mk:confirm(result.title, result.message, 'warn') {
				return null
			}
			result = result.confirm()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', '')
		}
		'reset' => eval {
			var result = inst.reset()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			if !Mk:confirm(result.title, result.message, 'warn') {
				return null
			}
			result = result.confirm()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', '')
		}
		* => Mk:dialog(MIEXP_CONST.notification_head, MIEXP_CONST.cmdnotfound_dialog(), 'error')
	}
}

@on_help(note, update) {
	if Plugin:config.debugMode { <: '@on_help' }
	if (note.text.len > 0) {
		Mk:dialog(MIEXP_CONST.notification_head, MIEXP_CONST.formnotempty_dialog() 'error')
		return null
	}
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	update('text', inst.help().message)
}

Plugin:register_post_form_action(MIEXP_CONST.cmd_formtitle() on_cmd)
if Plugin:config.commandlineHelp { Plugin:register_post_form_action(MIEXP_CONST.help_formtitle() on_help) }
on_load()
