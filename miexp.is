/// @0.13.3
### {
	name: "MiExp"
	author: "zawa-ch."
	description: "あなたのMisskeyでの活動から経験値を集計します"
	version: "1.1.2"
	permissions: [
		//	write:notifications
		//	ログインやレベルアップを通知するために必要になります。
		//	(設定で無効化することもできます)
		'write:notifications'
	]
	config: {
		enableNotification: {
			type: 'bool'
			label: '通知の有効化'
			description: 'このプラグインが通知を送信することを許可します。'
			default: true
		}
		commandlineHelp: {
			type: 'bool'
			label: 'コマンドラインのヘルプ'
			description: '投稿フォームのプラグインコマンドにコマンドラインのヘルプを表示するボタンを追加します。'
			default: true
		}
		debugMode: {
			type: 'bool'
			label: 'デバッグモード'
			description: 'デバッグを有効化します。有効化するとすべてのデバッグメッセージ、通知、エラー出力などがデバッグコンソールに出力されます。'
			default: false
		}
	}
}
//	1.2.0 update
//	経験値計算アルゴリズムの調整

let MIEXP_CONST = {
	savedata_key: 'miexp/savedata'
	activitycache_key: 'miexp/activity_cache'
	notification_head: 'MiExp'
	notification_icon: null
	//	If you want to translate, edit here
	cmd_formtitle: @(){`MiExp: コマンドライン実行`}
	help_formtitle: @(){`MiExp: コマンドラインヘルプ`}
	cmdnotfound_dialog: @(){`指定されたコマンドは存在しません。help と入力してコマンドライン実行をすることでコマンドラインヘルプを確認できます。`}
	formnotempty_dialog: @(){`フォームが空ではありません。この操作を行うには、フォームを空にする必要があります。`}
}

@MiExpSaveUtil(save) {
	@is_type(value, type) { Core:type(value) == type }
	//	セーブデータからバージョンを検出する
	//	save: any	セーブデータ
	//	<- num|null	検出したバージョン、検出できない場合はnull
	@detect_version(save) {
		if Core:type(save) != 'obj' { return null }
		if Core:type(save.schema) != 'obj' { return 0 }
		if Core:type(save.schema.version) != 'num' { return null }
		if save.schema.version < 1 || save.schema.version > 1 { return null }
		save.schema.version
	}
	let LATEST_VERSION = 1
	//	セーブデータの妥当性を検出するバージョン別関数
	let validation_detector = [
		//	version 0 (1.0.0 - 1.0.3)
		@(save) { is_type(save.loginday, 'num') && is_type(save.loginmap, 'arr') && is_type(save.subscore, 'num') && is_type(save.score, 'num') && is_type(save.level, 'num') && is_type(save.lastupdate, 'num') }
		//	version 1 (1.1.0 -)
		@(save) {
			if Core:not(is_type(save.schema, 'obj') && is_type(save.exp, 'obj') && is_type(save.state, 'obj') && is_type(save.loginmap, 'arr')) { return false }
			if Core:not(is_type(save.schema.context, 'str') && is_type(save.schema.version, 'num')) { return false }
			save.schema.context == 'miexp' && save.schema.version == 1
		}
	]
	let LOCALTIME_DIFF = Date:parse( `{Date:year()}/{Date:month()}/{Date:day()} 0:00 UTC`) - Date:parse(`{Date:year()}/{Date:month()}/{Date:day()} 0:00` )
	//	セーブデータのアップグレードを行うバージョン別関数
	let updator = [
		//	version 0 (-> 1)
		@(save) { { schema: { context: 'miexp', version: 1 }, lastlogin: ((save.lastupdate * 24 + 5) * 3600000 - LOCALTIME_DIFF), exp: { level: save.level, gauge: save.score, points: save.subscore }, state: { login: save.loginday }, loginmap: save.loginmap } }
		//	version 1 (latest)
		@(save) { save }
	]
	var data = if Core:type(save) == 'obj' { Obj:copy(save) } else { save }
	{
		//	セーブデータを取得する
		savedata: @() { data }
		//	バージョンを取得する
		version: @() { detect_version(data) }
		//	セーブデータの妥当性を取得する
		is_valid: @() {
			let v = detect_version(data)
			if !is_type(v, 'num') { return false }
			validation_detector[v](data)
		}
		//	アップグレード可能かを取得する
		is_upgradable: @() {
			let v = detect_version(data)
			is_type(v, 'num') && LATEST_VERSION != v
		}
		is_latest: @() {
			let v = detect_version(data)
			LATEST_VERSION == v
		}
		//	セーブデータのアップグレードを行う
		upgrade: @() {
			var v = detect_version(data)
			if !is_type(v, 'num') { return { error: 'VERSION_CANT_DETECT' } }
			if !validation_detector[v](data) { return { error: 'INVALID_SAVEDATA' } }
			if LATEST_VERSION == v { return { result: 'NO_UPDATE_NEEDED' } }
			var s = Obj:copy(data)
			loop {
				s = updator[v](s)
				let nv = detect_version(s)
				if nv != (v + 1) { return { error: 'VERSION_ASSERTION_FAILED' } }
				if !validation_detector[nv](s) { return { error: 'SCHEMA_ASSERTION_FAILED' } }
				if LATEST_VERSION == nv { break }
				v = nv
			}
			data = s
			{ result: 'UPDATED' }
		}
	}
}

@MiExp(context) {
	@check_type(obj, type) { Core:type(obj) == type }
	@value_or(value, alt) { if !check_type(value 'null') { value } else { alt } }
	//	ゲージ1本分の経験値量
	let EXP_GAUGE_CAPACITY = 256
	//	ローカライゼーションデータ
	//	If you want to translate, edit here
	let LOCALIZATION = {
		welcome_message: @(){`**MiExp**へようこそ！{Str:lf}{Str:lf}このプラグインは通知を使用します。{Str:lf}設定を変更することで無効化することも可能です。{Str:lf}`}
		earnedexp_message: @(exp){`獲得した経験値: {exp}`}
		earnedexp_base: @(exp){`<small>- 基本ポイント: {exp}</small>`}
		earnedexp_unidirectional: @(exp){`<small>- 単方向的活動ポイント: {exp}</small>`}
		earnedexp_bidirectional: @(exp){`<small>- 双方向的活動ポイント: {exp}</small>`}
		levelup_message: @(){`レベルアップしました！`}
		level_title: @(){`**MiExp 現在のレベル**`}
		logindays: @(days){`ログイン日数: **{days}**日`}
		currentlevel: @(lv){`現在のレベル: **{lv}**`}
		level_progress: @(x, sub, scale, next){`現在の経験値: **{Math:floor((x+sub/scale)/next*10000)/100}%** (**[{x}]**<small>**+{sub}** /[{next}]</small>)`}
		datanotexist_head: @(){`データがありません`}
		datanotexist_body: @(){`MiExpのデータが存在しないため、現在のレベルを確認できません。`}
		invalidtype_dialog_head: @(){`形式が異なります`}
		invalidtype_dialog_body: @(){`入力されたデータは有効なMiExpデータではありません。`}
		upgradefailure_dialog_head: @(){`アップグレードに失敗しました`}
		upgradefailure_dialog_body: @(){`入力されたデータを最新のバージョンに変換するときに問題が発生しました。`}
		overwrite_dialog_head: @(){`この操作はデータを上書きします`}
		overwrite_dialog_body: @(){`この操作によってもとあったデータは失われます。取り消すことはできません。`}
		erase_dialog_head: @(){`データを削除します`}
		erase_dialog_body: @(){`この操作によってデータは失われます。取り消すことはできません。後悔しませんね?`}
		cmdhelp: @(){[
			`MiExp ヘルプ`
			``
			`**利用可能なコマンド**(すべてのコマンドは大文字小文字を区別します)`
			`help    このヘルプを表示する`
			`share   共有テキストを表示する`
			`export  MiExpデータのエクスポートを行う`
			`import <jsonobject>`
			`        MiExpデータのインポートを行う`
			`reset   MiExpデータを消去する`
			`なにも入力せずにコマンドラインを実行するとshareが実行されます。`
			``
			`**MiExp 経験値**`
			`MiExp経験値はその日の最初のログイン時に加算されます。`
			`経験値に影響する要素は以下のとおりです。`
			`・直近のログイン日数`
			`・フォローの数`
			`・直近のフォロー解除`
			`・前日のノート`
			`・前日のリアクション`
			`MiExp経験値にはゲージが存在し、{EXP_GAUGE_CAPACITY}経験値で1本分のゲージになります。`
			`ゲージを一定数貯めることでレベルを上げることができます。`
			`レベルアップに必要なゲージ数は現在のレベルによって変化します。`
			`tips: 一日に大量のアクティビティを行うよりも、毎日ログインを行って継続的に活動したほうが効率が良くなるよう、経験値アルゴリズムは調整されています。`
			``
			`**MiExp利用上の注意**`
			`MiExpはMisskeyプラグインの特性上、知識があればデータの変更やコードの改変を行うことが簡単にできます。`
			`MiExpは人との競争を目的として開発されたものではありません。節度をもって楽しく活用してください。`
		].join(Str:lf)}
	}
	if !check_type(context, 'obj') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context type is not obj' } } }
	if !check_type(context.load, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.load type is not fn' } } }
	if !check_type(context.save, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.save type is not fn' } } }
	if !check_type(context.get_activity, 'fn') { return { error: { code: 'INVALID_CONTEXT', message: 'argument context.get_activity type is not fn' } } }
	@dbg(msg) { if check_type(context.debug, 'fn') { context.debug(msg) } }
	//	ログインマップデータの更新
	@update_loginmap(map, duration) {
		var r = map.copy()
		r.reverse()
		r.push(duration)
		r.reverse()
		r.slice(0, 14)
	}
	//	AiScript標準日付 -> Miexp日付データ変換
	//	date: num	AiScriptで使用される日付データ
	@convert_date(date) {
		let LOCALTIME_DIFF = Date:parse( `{Date:year(date)}/{Date:month(date)}/{Date:day(date)} 0:00 UTC`) - Date:parse(`{Date:year(date)}/{Date:month(date)}/{Date:day(date)} 0:00` )
		Math:floor(((date + LOCALTIME_DIFF) / 3600000 - 5) / 24)
	}
	//	経験値計算
	@calc_exp(activitydata) {
		let result = eval {
			let s = eval {
				let sf = eval {
					let ft = 128	// フォローアクティビティの基準しきい値(これを超えると一気に増えにくくなる)
					let fs = 64	// フォローアクティビティポイントの倍率(しきい値に一致する点での付与ポイント)
					let f_parts = [
						Math:sqrt( activitydata.follow.following / ft ) * (ft - Math:min(activitydata.follow.following, ft)) / ft
						Math:sqrt(Math:sqrt(Math:sqrt( activitydata.follow.following / ft ))) * Math:min(activitydata.follow.following, ft) / ft
					]
					{ parts: f_parts, result: (f_parts[0] + f_parts[1]) * fs }
				}
				let ss = eval {
					let sa = 64	// ログイン頻度が高い場合に付与されるボーナスの最大
					Math:sqrt( activitydata.login_freq / 14 ) * sa
				}
				let rs = 1	// リムーブペナルティの倍率
				{ follow: sf, login: ss, result: Math:floor( Math:max(0, sf.result + ss - activitydata.follow.remove * rs) ) }
			}
			let u = eval {
				let as = activitydata.notes.normal + Math:sqrt(activitydata.notes.renote)
				let ut = 128	// 単方向的アクティビティの基準しきい値(これを超えると増えにくくなる)
				let us = 128	// 単方向的アクティビティポイントの倍率(しきい値に一致する点での付与ポイント)
				{ score: as, result: Math:floor( Math:sqrt(Math:sqrt( as / ut )) * us ) }
			}
			let b = eval {
				let at = 256	// アクティビティの基準しきい値(これを超えると増えにくくなる)
				let ft = 256	// フォローの基準しきい値(これを超えると増えにくくなる)
				let as = eval {
					let rw = 4	// リプライのポイント付けの重み
					let aw = 1	// リアクションのポイント付けの重み
					let sb = activitydata.notes.reply * rw + activitydata.reaction * aw
					{ base: sb, s1: sb / at, s2: sb / ( at * Math:sqrt( Math:max(1,activitydata.follow.following) / ft ) ) }
				}
				let b_parts = [
					Math:sqrt( as.s1 ) * ( 1 - Math:min(as.s1, 1) ) * ( 1 - Math:min(activitydata.follow.following / ft, 1) )
					Math:sqrt(Math:sqrt(Math:sqrt( as.s1 ))) * Math:min(as.s1, 1) * ( 1 - Math:min(activitydata.follow.following / ft, 1) )
					Math:sqrt( as.s2 ) * ( 1 - Math:min(as.s2, 1) ) * Math:min(activitydata.follow.following / ft, 1)
					Math:sqrt(Math:sqrt(Math:sqrt( as.s2 ))) * Math:min(as.s2, 1) * Math:min(activitydata.follow.following / ft, 1)
				]
				let ss = 256	// 双方向的アクティビティポイントの倍率(しきい値に一致する点での付与ポイント)
				{ score: as, parts: b_parts, result: Math:floor( (b_parts[0] + b_parts[1] + b_parts[2] + b_parts[3]) * ss ) }
			}
			{ params: activitydata, base: s, unidirectional: u, bidirectional: b, result: s.result + u.result + b.result }
		}
		dbg(Json:stringify(result))
		result
	}
	//	次レベルまでに必要なゲージ数の取得
	@calc_nextlevel(level) { 1 + Math:floor( Math:sqrt(level / 64) * 8 ) }
	//	レベルアップ処理
	@levelup(current, earned) {
		var r = {
			level: current.level + 0
			gauge: Math:floor(value_or(current.gauge, 0) + (value_or(current.points, 0) + earned) / EXP_GAUGE_CAPACITY)
			points: Math:floor((value_or(current.points, 0) + earned) % EXP_GAUGE_CAPACITY)
		}
		loop {
			let g = calc_nextlevel(r.level)
			if r.gauge < g { break }
			r.gauge = r.gauge - g
			r.level = r.level + 1
		}
		r
	}
	//	セーブデータが新規データであるかを取得
	@is_newdata(savedata) { !check_type(savedata, 'obj') }
	//	セーブデータが有効であるかを取得
	@is_validdata(savedata) {
		let s = MiExpSaveUtil(savedata)
		s.is_valid() && s.is_latest()
	}
	//	セーブデータとその日との日数の差を取得
	@login_duration(savedata, date) { convert_date(date) - convert_date(value_or(savedata.lastlogin, 0)) }
	//	その日のログイン処理を行えるかを取得
	@is_login_available(savedata, date) {
		if is_newdata(savedata) { return true }
		if !check_type(savedata.lastlogin, 'num') { return true }
		login_duration(savedata, date) > 0
	}
	//	新規データの構築
	@create_newdata() {
		{
			schema: { context: 'miexp', version: 1 }
			lastlogin: null
			exp: { level: 0, gauge: 0, points: 0 }
			state: { login: 0 }
			loginmap: eval {
				var a = []
				for 14 { a.push(null) }
				a
			}
		}
	}
	var data = context.load()
	dbg('loaded savedata')
	dbg(Json:stringify({ savedata: data }))

	{
		//	ヘルプを表示するための要素を取得
		help: @() {
			dbg('@Miexp:help')
			let message = LOCALIZATION.cmdhelp()
			{ message: message }
		}
		//	共有用テキスト要素を取得
		share: @() {
			dbg('@Miexp:share')
			if !is_validdata(data) {
				return { error: { code: 'SAVEDATA_NOT_EXIST', message: LOCALIZATION.datanotexist_body(), title: LOCALIZATION.datanotexist_head() } }
			}
			let message = [
				LOCALIZATION.level_title()
				LOCALIZATION.logindays(data.state.login)
				LOCALIZATION.currentlevel(data.exp.level)
				LOCALIZATION.level_progress(data.exp.gauge, data.exp.points, EXP_GAUGE_CAPACITY, calc_nextlevel(data.exp.level))
			].join(Str:lf)
			{ message: message }
		}
		//	その日のログイン処理を行えるかを取得
		is_login_available: @() {
			dbg('@Miexp:is_login_available')
			{ result: is_login_available(data, Date:now()) }
		}
		//	ログイン処理を実行
		login: @() {
			dbg('@Miexp:login')
			let current_time = Date:now()
			if !is_login_available(data, current_time) {
				dbg('already logged in')
				return { result: 'ALREADY_LOGGED_IN', message: null }
			}
			var message = []
			if is_newdata(data) {
				dbg('new data')
				message.push(LOCALIZATION.welcome_message())
				data = create_newdata()
			}
			dbg(Json:stringify({data: data}))
			if !is_validdata(data) {
				return { error: { code: 'INVALID_SAVEDATA', message: 'Invalid savedata loaded.' } }
			}
			let loginmap = if Core:type(data.lastlogin) == 'num' { update_loginmap(data.loginmap, login_duration(data, current_time)) } else { data.loginmap }
			dbg(Json:stringify({ loginmap: loginmap }))
			let login_freq = eval {
				var r = 0
				var d = 0
				for let i, Math:min(loginmap.len, 14) {
					r += 1
					d += value_or(loginmap[i], 1)
					if d >= 14 { break }
				}
				r
			}
			let activity = context.get_activity()
			dbg(Json:stringify({ activity: activity }))
			if !check_type(activity, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.normal, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.normal', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.renote, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.renote', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.notes.reply, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.notes.reply', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow, 'obj') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow.following, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow.following', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.follow.remove, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.follow.remove', message: 'Callback "get_activity" returns invalid object.' } } }
			if !check_type(activity.reaction, 'num') { return { error: { code: 'INVALID_ACTIVITY_DATA', path: '.reaction', message: 'Callback "get_activity" returns invalid object.' } } }
			let earned_exp = calc_exp({login_freq: login_freq, notes: activity.notes, follow: activity.follow, reaction: activity.reaction})
			dbg(Json:stringify({earned_exp: earned_exp}))
			message.push(LOCALIZATION.earnedexp_message(earned_exp.result))
			message.push(LOCALIZATION.earnedexp_base(earned_exp.base.result))
			message.push(LOCALIZATION.earnedexp_unidirectional(earned_exp.unidirectional.result))
			message.push(LOCALIZATION.earnedexp_bidirectional(earned_exp.bidirectional.result))
			let old_level = value_or(data.exp.level, 0)
			let new_exp = levelup(data.exp, earned_exp.result)
			dbg(Json:stringify({ old_level: old_level, new_exp: new_exp }))
			if (!is_newdata(data)) && (old_level < new_exp.level) {
				dbg(`level up`)
				message.push(LOCALIZATION.levelup_message())
			}
			data.lastlogin = current_time
			data.exp = new_exp
			data.state.login = value_or(data.state.login, 0) + 1
			data.loginmap = loginmap
			dbg(Json:stringify({ updated_savedata: data }))
			message.push('')
			message.push(LOCALIZATION.level_title())
			message.push(LOCALIZATION.logindays(data.state.login))
			message.push(LOCALIZATION.currentlevel(data.exp.level))
			message.push(LOCALIZATION.level_progress(data.exp.gauge, data.exp.points, EXP_GAUGE_CAPACITY, calc_nextlevel(data.exp.level)))
			context.save(data)
			{ result: 'LOGIN_SUCCESS', message: message.join(Str:lf) }
		}
		//	データのエクスポート
		export_data: @() {
			dbg('@Miexp:export_data')
			if !is_validdata(data) {
				return { error: { code: 'SAVEDATA_NOT_EXIST', message: LOCALIZATION.datanotexist_body(), title: LOCALIZATION.datanotexist_head() } }
			}
			{ result: data, to_json: @() { Json:stringify(data) } }
		}
		//	データのインポート
		import_data: @(new_data) {
			dbg('@Miexp:import_data')
			dbg(Json:stringify({new_data: new_data}))
			let s = MiExpSaveUtil(new_data)
			if !s.is_valid() {
				return { error: { code: 'INVALID_SAVEDATA', message: LOCALIZATION.invalidtype_dialog_body(), title: LOCALIZATION.invalidtype_dialog_head() } }
			}
			if s.is_upgradable() {
				let r = s.upgrade()
				if !check_type(r.error, 'null') { return { error: { code: 'SAVEDATA_UPGRADE_FAILED', inner: r.error, message: LOCALIZATION.upgradefailure_dialog_body(), title: LOCALIZATION.upgradefailure_dialog_head() } } }
			}
			{
				message: LOCALIZATION.overwrite_dialog_body()
				title: LOCALIZATION.overwrite_dialog_head()
				confirm: @() {
					data = s.savedata()
					context.save(s.savedata())
					{ result: 'SUCCESS' }
				}
			}
		}
		//	データの消去
		reset: @() {
			dbg('@Miexp:reset')
			{
				message: LOCALIZATION.erase_dialog_body()
				title: LOCALIZATION.erase_dialog_head()
				confirm: @() {
					data = null
					context.save(null)
					{ result: 'SUCCESS' }
				}
			}
		}
	}
}

//	nullの場合に代替オブジェクトを適用
@value_or(value, alt) { if Core:type(value) != 'null' { value } else { alt } }

//	文字列が指定した文字列から開始するかを取得
@starts_with(str, search) { str.index_of(search) == 0 }

//	文字列から指定した文字列以前の文字列を取得
@slice_before_with(str, search) {
	let i = str.index_of(search)
	if i >= 0 { str.slice(0, i) } else { null }
}

//	文字列から指定した文字列以降の文字列を取得
@slice_after_with(str, search) {
	let i = str.index_of(search)
	if i >= 0 { str.slice((i+search.len), str.len) } else { null }
}

@sum(array) {
	var result = 0
	for let i, array.len { result += array[i] }
	result
}

@merge(a1, a2) {
	let l = Math:max(a1.len, a2.len)
	let a = []
	for let i, l { a.push(i) }
	a.map(@(i) { a1[i] + a2[i] })
}

//	Misskey API 通知送信
@miexp_notify(body) { if Plugin:config.enableNotification { Mk:api('notifications/create' { body: body, header: MIEXP_CONST.notification_head, icon: MIEXP_CONST.notification_icon }) } }

//	プラグインデータ保存
@miexp_save(data) { Mk:save(MIEXP_CONST.savedata_key, data) }

//	プラグインデータ取得
@miexp_load() { Mk:load(MIEXP_CONST.savedata_key) }

//	経験値集計用データをMiExp本体に通知
@miexp_get_activity() {
	let activity = Mk:load(MIEXP_CONST.activitycache_key).activity
	Mk:save(MIEXP_CONST.activitycache_key, null)
	activity
}

//	チャートから経験値計算用のデータを取得
@miexp_collect_chart(inst) {
	if Plugin:config.debugMode { <: '@miexp_collect_chart' }
	var c = Mk:load(MIEXP_CONST.activitycache_key)
	if Core:type(c) != 'obj' { c = { activity: {}, wait_time: 5000 } }
	let chart_notes = Mk:api('charts/user/notes' { span: 'hour', limit: 24, userId: USER_ID })
	let chart_following = Mk:api('charts/user/following' { span: 'day', limit: 14, userId: USER_ID })
	let chart_reactions = Mk:api('charts/user/reactions' { span: 'hour', limit: 24, userId: USER_ID })
	if Plugin:config.debugMode { <: { chart_notes: chart_notes, chart_following: chart_following, chart_reactions: chart_reactions } }
	if Core:type(c.activity.notes) != 'obj' {
		c.activity.notes = eval {
			if Core:type(chart_notes.diffs) != 'obj' { return null }
			if Core:type(chart_notes.diffs.normal) != 'arr' { return null }
			if Core:type(chart_notes.diffs.renote) != 'arr' { return null }
			if Core:type(chart_notes.diffs.reply) != 'arr' { return null }
			{
				normal: Math:max(0, sum(chart_notes.diffs.normal))
				renote: Math:max(0, sum(chart_notes.diffs.renote))
				reply: Math:max(0, sum(chart_notes.diffs.reply))
			}
		}
	}
	if Core:type(c.activity.follow) != 'obj' {
		c.activity.follow = eval {
			if Core:type(chart_following.local) != 'obj' { return null }
			if Core:type(chart_following.local.followings) != 'obj' { return null }
			if Core:type(chart_following.local.followings.total[0]) != 'num' { return null }
			if Core:type(chart_following.local.followings.dec) != 'arr' { return null }
			{
				following: chart_following.local.followings.total[0]
				remove: sum(chart_following.local.followings.dec)
			}
		}
	}
	if Core:type(c.activity.reaction) != 'num' {
		c.activity.reaction = eval {
			if Core:type(chart_reactions.local) != 'obj' { return null }
			if Core:type(chart_reactions.local.count) != 'arr' { return null }
			if Core:type(chart_reactions.remote) != 'obj' { return null }
			if Core:type(chart_reactions.remote.count) != 'arr' { return null }
			sum(merge(chart_reactions.local.count, chart_reactions.remote.count))
		}
	}
	if Plugin:config.debugMode { <: c }
	let wait_time = c.wait_time
	c.wait_time = Math:min(c.wait_time * 6, 300000)
	Mk:save(MIEXP_CONST.activitycache_key, c)
	if Core:type(c.activity.notes) == 'obj' && Core:type(c.activity.follow) == 'obj' && Core:type(c.activity.reaction) == 'num' {
		if Plugin:config.debugMode { <: 'Data corrected, run login task' }
		let result = inst.login()
		if Plugin:config.debugMode { <: result }
		elif Core:type(result.error) != 'null' {
			<: result
			Mk:dialog(MIEXP_CONST.notification_head, `MiExp login returned error {result.error.code}`, 'error')
		}
		elif Core:type(result.message) == 'str' { miexp_notify(result.message) }
		else {}
	} else {
		if Plugin:config.debugMode { <: `Data fetch failed, retry in {wait_time}ms` }
		Async:timeout(wait_time, @() { miexp_collect_chart(inst) })
	}
}

let miexp_context = {
	save: miexp_save
	load: miexp_load
	get_activity: miexp_get_activity
	debug: if Plugin:config.debugMode { @(obj) { <: obj } } else { null }
}

@on_load() {
	if Plugin:config.debugMode { <: '@on_load' }
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	if inst.is_login_available().result {
		Mk:save(MIEXP_CONST.activitycache_key, null)
		miexp_collect_chart(inst)
	}
}

@on_cmd(note, update) {
	if Plugin:config.debugMode { <: '@on_cmd' }
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	let command = if note.text.len > 0 { value_or(slice_before_with(note.text ' ') note.text) } else { 'share' }
	if Plugin:config.debugMode { <: command }
	match (command) {
		'help' => eval {
			update('text', inst.help().message)
		}
		'share' => eval {
			let result = inst.share()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', result.message)
		}
		'export' => eval {
			let result = inst.export_data()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', result.to_json())
		}
		'import' => eval {
			let import_data = Json:parse(value_or(slice_after_with(note.text ' ') 'null'))
			var result = inst.import_data(import_data)
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			if !Mk:confirm(result.title, result.message, 'warn') {
				return null
			}
			result = result.confirm()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', '')
		}
		'reset' => eval {
			var result = inst.reset()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			if !Mk:confirm(result.title, result.message, 'warn') {
				return null
			}
			result = result.confirm()
			if Plugin:config.debugMode { <: Json:stringify(result) }
			if Core:type(result.error) != 'null' {
				Mk:dialog(result.error.title, result.error.message, 'error')
				return null
			}
			update('text', '')
		}
		* => Mk:dialog(MIEXP_CONST.notification_head, MIEXP_CONST.cmdnotfound_dialog(), 'error')
	}
}

@on_help(note, update) {
	if Plugin:config.debugMode { <: '@on_help' }
	if (note.text.len > 0) {
		Mk:dialog(MIEXP_CONST.notification_head, MIEXP_CONST.formnotempty_dialog() 'error')
		return null
	}
	let inst = MiExp(miexp_context)
	if Plugin:config.debugMode { <: inst }
	if Core:type(inst.error) != 'null' {
		<: inst
		Mk:dialog(MIEXP_CONST.notification_head, `MiExp constructor returned error {inst.error.code}`, 'error')
	}
	update('text', inst.help().message)
}

Plugin:register_post_form_action(MIEXP_CONST.cmd_formtitle() on_cmd)
if Plugin:config.commandlineHelp { Plugin:register_post_form_action(MIEXP_CONST.help_formtitle() on_help) }
on_load()
